#pragma once
#include "DeferredPipeline.h"

AQUA_BEGIN

struct ShadingPipelineVertex
{
	glm::vec3 Vertex;
	glm::vec2 TexCoord;
};

using ShadingPipelineQuad = std::array<ShadingPipelineVertex, 4>;

enum class ShadingModel
{
	ePBR                  = 1,
	BlinnPhong            = 2,
};

// An instance of this class is generated by the material system and also material system
// will keep track of this class internally

class ShadingPipeline : public vkEngine::GraphicsPipeline<ShadingPipelineQuad>
{
public:
	inline ShadingPipeline() = default;

public: // should be public
	inline ShadingPipeline(vkEngine::Context ctx, const vkEngine::PShader& shader,
		const glm::uvec2& scrSize);

	friend class MaterialSystem;

public:
	~ShadingPipeline() = default;

	inline virtual void UpdateDescriptors() override;

	virtual void Cleanup() override { /* Do nothing */ }

	void SetGeometry(const VertexResourceMap& geometry) { mGeometry = geometry; }
	inline void SetGeometryDescLocation(const std::string& tag, const glm::uvec3& location);

	virtual const vkEngine::GraphicsPipelineConfig& GetConfig() const override { return mBasicConfig; }

	/* Naming convention
	* prefix @ --> image resource
	* prefix $ --> storage buffer
	* prefix # --> uniform buffer
	* The other part is the name
	*/
	Resource& operator[](const std::string& tag) { return mResources[tag]; }
	const Resource& operator[](const std::string& tag) const { return mResources.at(tag); }

private:
	vkEngine::GraphicsPipelineConfig mBasicConfig;

	//ShadingModel mModel = ShadingModel::ePBR; // TODO: Not sure if we need this flag here

	ShadingPipelineQuad mQuad = 
	{
		ShadingPipelineVertex({0.0f, 1.0f, 0.0f}, {0.0f, 0.0f}), ShadingPipelineVertex({1.0f, 1.0f, 0.0f}, {1.0f, 0.0f}),
		ShadingPipelineVertex({1.0f, 0.0f, 0.0f}, {1.0f, 1.0f}), ShadingPipelineVertex({0.0f, 0.0f, 0.0f}, {0.0f, 1.0f})
	};

	vkEngine::Image mOutImage;

	vkEngine::Buffer<ShadingPipelineVertex> mVertexBuffer;
	vkEngine::Buffer<uint32_t> mIndexBuffer;

	vkEngine::Buffer<Material> mMaterials;
	VertexResourceMap mGeometry;

	ResourceMap mResources;

	vkEngine::Context mVulkanCtx;

private:
	inline void GenerateVertexAndIndexBuffers();

	inline void CreateFramebuffer(uint32_t width, uint32_t height);
	inline void SetupBasicConfig(const glm::uvec2& scrSize);

	inline virtual void SubmitRenderable(const MyRenderable& renderable) const override;

	virtual size_t GetVertexCount() const override { return 4; }
	virtual size_t GetIndexCount() const override { return 6; }

	inline virtual void BindVertexBuffers(vk::CommandBuffer commandBuffer) const override;
	inline virtual void BindIndexBuffer(vk::CommandBuffer commandBuffer) const override;
};

inline ShadingPipeline::ShadingPipeline(vkEngine::Context ctx, const vkEngine::PShader& shader,
	const glm::uvec2& scrSize)
	: mVulkanCtx(ctx)
{
	this->SetShader(shader);

	SetupBasicConfig(scrSize);

	auto rcb = mVulkanCtx.FetchRenderContextBuilder(vk::PipelineBindPoint::eGraphics);
	vkEngine::RenderContextCreateInfo ctxCreateInfo{};

	vkEngine::ImageAttachmentInfo attachInfo{};
	attachInfo.Format = vk::Format::eR8G8B8A8Snorm;
	attachInfo.Layout = vk::ImageLayout::eColorAttachmentOptimal;
	attachInfo.LoadOp = vk::AttachmentLoadOp::eLoad;
	attachInfo.StoreOp = vk::AttachmentStoreOp::eStore;
	attachInfo.Samples = vk::SampleCountFlagBits::e1;
	attachInfo.Usage = vk::ImageUsageFlagBits::eColorAttachment;
	attachInfo.StencilLoadOp = vk::AttachmentLoadOp::eDontCare;
	attachInfo.StencilStoreOp = vk::AttachmentStoreOp::eDontCare;

	ctxCreateInfo.Attachments.push_back(attachInfo);

	attachInfo.Format = vk::Format::eD24UnormS8Uint;
	attachInfo.Layout = vk::ImageLayout::eDepthStencilAttachmentOptimal;
	attachInfo.LoadOp = vk::AttachmentLoadOp::eLoad;
	attachInfo.StoreOp = vk::AttachmentStoreOp::eStore;
	attachInfo.Samples = vk::SampleCountFlagBits::e1;
	attachInfo.Usage = vk::ImageUsageFlagBits::eDepthStencilAttachment;
	attachInfo.StencilLoadOp = vk::AttachmentLoadOp::eDontCare;
	attachInfo.StencilStoreOp = vk::AttachmentStoreOp::eDontCare;

	ctxCreateInfo.Attachments.push_back(attachInfo);

	ctxCreateInfo.UsingDepthAttachment = true;

	mBasicConfig.TargetContext = rcb.MakeContext(ctxCreateInfo);

	CreateFramebuffer(scrSize.x, scrSize.y);

	GenerateVertexAndIndexBuffers();
}

inline void ShadingPipeline::SubmitRenderable(const MyRenderable& renderable) const
{
	_STL_ASSERT(false, "Not allowed to call ShadingPipeline::SubmitRenderable");

	auto vb = mVertexBuffer;
	vb << renderable;

	auto ib = mIndexBuffer;

	ib << (uint32_t) 0 << (uint32_t) 1 << (uint32_t) 2 <<
		(uint32_t) 2 << (uint32_t) 3 << (uint32_t) 0;
}

inline void ShadingPipeline::UpdateDescriptors()
{
	vkEngine::DescriptorWriter& writer = this->GetDescriptorWriter();
	vkEngine::PShader shader = this->GetShader();

	auto updateImage = [&writer, &shader](const vkEngine::DescriptorLocation& location, vkEngine::Image image)
	{
		vkEngine::SampledImageWriteInfo sampledImageInfo{};
		sampledImageInfo.ImageLayout = vk::ImageLayout::eReadOnlyOptimal;
		sampledImageInfo.ImageView = image.GetIdentityImageView();
		sampledImageInfo.Sampler = *image.GetSampler();

		if(!shader.IsEmpty(location.SetIndex, location.Binding))
			writer.Update(location, sampledImageInfo);
	};

	auto updateStorageBuffer = [&writer, &shader](
		const vkEngine::DescriptorLocation& location, vkEngine::Core::BufferChunk buffer)
	{
		vkEngine::StorageBufferWriteInfo storageBuffer{};
		storageBuffer.Buffer = buffer.BufferHandles->Handle;
		
		if (!shader.IsEmpty(location.SetIndex, location.Binding) && storageBuffer.Buffer)
			writer.Update(location, storageBuffer);
	};

	auto updateUniformBuffer = [&writer, &shader](
		const vkEngine::DescriptorLocation& location, vkEngine::Core::BufferChunk buffer)
	{
		vkEngine::UniformBufferWriteInfo uniformBuffer{};
		uniformBuffer.Buffer = buffer.BufferHandles->Handle;

		if (!shader.IsEmpty(location.SetIndex, location.Binding) && uniformBuffer.Buffer)
			writer.Update(location, uniformBuffer);
	};

	// The Geometry images always placed in the set zero
	uint32_t i = 0;

	for (const auto& [tag, vertRsc] : mGeometry)
	{
		if (tag == TAG_DEPTH_STENCIL)
			continue;

		updateImage(vertRsc.Location, vertRsc.Image);
	}

	for (const auto& [tag, resource] : mResources)
	{
		if (tag[0] == '@')
			updateImage(resource.Location, resource.Image);
		if (tag[0] == '$')
			updateStorageBuffer(resource.Location, resource.Buffer);
		if (tag[0] == '#')
			updateUniformBuffer(resource.Location, resource.Buffer);
	}
}

inline void ShadingPipeline::CreateFramebuffer(uint32_t width, uint32_t height)
{
	SetFramebuffer(mBasicConfig.TargetContext.CreateFramebuffer(width, height));

	auto cAttachs = GetFramebuffer().GetColorAttachments();
	mOutImage = cAttachs[0];
}

inline void ShadingPipeline::SetupBasicConfig(const glm::uvec2& scrSize)
{
	mBasicConfig.CanvasScissor = vk::Rect2D(scrSize.x, scrSize.y);
	mBasicConfig.CanvasView = vk::Viewport(0.0f, 0.0f, (float)scrSize.x, (float)scrSize.y, 0.0f, 1.0f);

	mBasicConfig.IndicesType = vk::IndexType::eUint32;

	mBasicConfig.VertexInput.Bindings.emplace_back(0, static_cast<uint32_t>(sizeof(ShadingPipelineVertex)));

	mBasicConfig.VertexInput.Attributes.emplace_back(0, 0, vk::Format::eR32G32B32Sfloat, 0);
	mBasicConfig.VertexInput.Attributes.emplace_back(1, 0, vk::Format::eR32G32Sfloat, static_cast<uint32_t>(sizeof(glm::vec3)));

	mBasicConfig.SubpassIndex = 0;

	mBasicConfig.DepthBufferingState.DepthBoundsTestEnable = false;
	mBasicConfig.DepthBufferingState.DepthCompareOp = vk::CompareOp::eLess;
	mBasicConfig.DepthBufferingState.DepthTestEnable = true;
	mBasicConfig.DepthBufferingState.DepthWriteEnable = true;
	mBasicConfig.DepthBufferingState.MaxDepthBounds = 1.0f;
	mBasicConfig.DepthBufferingState.MinDepthBounds = 0.0f;
	mBasicConfig.DepthBufferingState.StencilTestEnable = false;

	mBasicConfig.Rasterizer.CullMode = vk::CullModeFlagBits::eBack;
	mBasicConfig.Rasterizer.FrontFace = vk::FrontFace::eCounterClockwise;
	mBasicConfig.Rasterizer.LineWidth = 0.01f;
	mBasicConfig.Rasterizer.PolygonMode = vk::PolygonMode::eFill;
}

void ShadingPipeline::GenerateVertexAndIndexBuffers()
{
	auto mma = mVulkanCtx.CreateResourcePool();

	mVertexBuffer = mma.CreateBuffer<ShadingPipelineVertex>(
		vk::BufferUsageFlagBits::eVertexBuffer, vk::MemoryPropertyFlagBits::eDeviceLocal);
	mIndexBuffer = mma.CreateBuffer<uint32_t>(
		vk::BufferUsageFlagBits::eIndexBuffer, vk::MemoryPropertyFlagBits::eDeviceLocal);

	auto vertBuf = mma.CreateBuffer<ShadingPipelineVertex>(
		vk::BufferUsageFlagBits::eVertexBuffer, vk::MemoryPropertyFlagBits::eHostCoherent);
	auto idxBuf = mma.CreateBuffer<MyIndex>(
		vk::BufferUsageFlagBits::eIndexBuffer, vk::MemoryPropertyFlagBits::eHostCoherent);

	vertBuf << mQuad;
	idxBuf << std::initializer_list<MyIndex>({ 0, 1, 2, 2, 3, 0 });

	mVertexBuffer.Resize(vertBuf.GetSize());
	mIndexBuffer.Resize(idxBuf.GetSize());

	vkEngine::CopyBuffer(mVertexBuffer, vertBuf);
	vkEngine::CopyBuffer(mIndexBuffer, idxBuf);
}

void ShadingPipeline::BindVertexBuffers(vk::CommandBuffer commandBuffer) const
{
	commandBuffer.bindVertexBuffers(0, mVertexBuffer.GetNativeHandles().Handle, { 0 });
}

void ShadingPipeline::BindIndexBuffer(vk::CommandBuffer commandBuffer) const
{
	commandBuffer.bindIndexBuffer(mIndexBuffer.GetNativeHandles().Handle, 0, vk::IndexType::eUint32);
}

void ShadingPipeline::SetGeometryDescLocation(const std::string& tag, const glm::uvec3& location)
{
	if (mGeometry.find(tag) != mGeometry.end())
		mGeometry[tag].Location = { location.x, location.y, location.z };
}

AQUA_END
